{
  "Comment": "Chaos Engineering Experiment Workflow - Validates system resilience by injecting controlled failures",
  "StartAt": "LogExperimentStart",
  "States": {
    "LogExperimentStart": {
      "Type": "Pass",
      "Comment": "Log the start of the experiment with timestamp",
      "Result": {
        "experimentStartTime": "$.experimentStartTime",
        "experimentId": "$.experimentId"
      },
      "ResultPath": "$.experimentMetadata",
      "Next": "PreExperimentHealthCheck"
    },

    "PreExperimentHealthCheck": {
      "Type": "Task",
      "Comment": "Validate system is healthy before injecting chaos",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${ValidateHealthFunctionArn}",
        "Payload": {
          "targetGroupArn.$": "$.targetGroupArn",
          "loadBalancerArn.$": "$.loadBalancerArn",
          "expectedHealthyHosts.$": "$.expectedHealthyHosts",
          "checkType": "pre"
        }
      },
      "ResultSelector": {
        "healthStatus.$": "$.Payload.healthStatus",
        "healthy.$": "$.Payload.healthy",
        "metrics.$": "$.Payload.metrics",
        "evaluation.$": "$.Payload.evaluation",
        "summary.$": "$.Payload.summary",
        "timestamp.$": "$.Payload.timestamp"
      },
      "ResultPath": "$.preExperimentHealth",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ExperimentFailedPreCheck"
        }
      ],
      "Next": "EvaluatePreExperimentHealth"
    },

    "EvaluatePreExperimentHealth": {
      "Type": "Choice",
      "Comment": "Abort experiment if system is not healthy",
      "Choices": [
        {
          "Variable": "$.preExperimentHealth.healthy",
          "BooleanEquals": true,
          "Next": "SelectTargetInstance"
        }
      ],
      "Default": "ExperimentAbortedUnhealthy"
    },

    "SelectTargetInstance": {
      "Type": "Task",
      "Comment": "Select a random healthy instance from Auto Scaling Group",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${GetTargetFunctionArn}",
        "Payload": {
          "autoScalingGroupName.$": "$.autoScalingGroupName"
        }
      },
      "ResultSelector": {
        "instanceId.$": "$.Payload.instanceId",
        "availabilityZone.$": "$.Payload.availabilityZone",
        "healthStatus.$": "$.Payload.healthStatus",
        "lifecycleState.$": "$.Payload.lifecycleState",
        "privateIpAddress.$": "$.Payload.privateIpAddress",
        "instanceType.$": "$.Payload.instanceType",
        "totalHealthyInstances.$": "$.Payload.totalHealthyInstances",
        "message.$": "$.Payload.message"
      },
      "ResultPath": "$.selectedTarget",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ExperimentFailedTargetSelection"
        }
      ],
      "Next": "RecordTargetSelection"
    },

    "RecordTargetSelection": {
      "Type": "Pass",
      "Comment": "Record the selected target for logging",
      "Parameters": {
        "instanceId.$": "$.selectedTarget.instanceId",
        "availabilityZone.$": "$.selectedTarget.availabilityZone",
        "totalHealthyInstancesBeforeFailure.$": "$.selectedTarget.totalHealthyInstances",
        "selectionTimestamp.$": "$$.State.EnteredTime"
      },
      "ResultPath": "$.targetRecord",
      "Next": "InjectFailure"
    },

    "InjectFailure": {
      "Type": "Task",
      "Comment": "Terminate the selected instance to inject chaos",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${InjectFailureFunctionArn}",
        "Payload": {
          "instanceId.$": "$.selectedTarget.instanceId",
          "dryRun": false
        }
      },
      "ResultSelector": {
        "action.$": "$.Payload.action",
        "instanceId.$": "$.Payload.instanceId",
        "previousState.$": "$.Payload.previousState",
        "currentState.$": "$.Payload.currentState",
        "message.$": "$.Payload.message",
        "timestamp.$": "$.Payload.timestamp"
      },
      "ResultPath": "$.failureInjection",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 2,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ExperimentFailedInjection"
        }
      ],
      "Next": "WaitForRecovery"
    },

    "WaitForRecovery": {
      "Type": "Wait",
      "Comment": "Wait for Auto Scaling to detect failure and launch replacement instance",
      "Seconds": 180,
      "Next": "PostExperimentHealthCheck"
    },

    "PostExperimentHealthCheck": {
      "Type": "Task",
      "Comment": "Validate system recovered after chaos injection",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${ValidateHealthFunctionArn}",
        "Payload": {
          "targetGroupArn.$": "$.targetGroupArn",
          "loadBalancerArn.$": "$.loadBalancerArn",
          "expectedHealthyHosts.$": "$.expectedHealthyHosts",
          "checkType": "post"
        }
      },
      "ResultSelector": {
        "healthStatus.$": "$.Payload.healthStatus",
        "healthy.$": "$.Payload.healthy",
        "metrics.$": "$.Payload.metrics",
        "evaluation.$": "$.Payload.evaluation",
        "summary.$": "$.Payload.summary",
        "timestamp.$": "$.Payload.timestamp"
      },
      "ResultPath": "$.postExperimentHealth",
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException"
          ],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "ResultPath": "$.error",
          "Next": "ExperimentFailedPostCheck"
        }
      ],
      "Next": "EvaluatePostExperimentHealth"
    },

    "EvaluatePostExperimentHealth": {
      "Type": "Choice",
      "Comment": "Determine if system successfully recovered",
      "Choices": [
        {
          "Variable": "$.postExperimentHealth.healthy",
          "BooleanEquals": true,
          "Next": "ExperimentSucceeded"
        }
      ],
      "Default": "SystemDidNotRecover"
    },

    "ExperimentSucceeded": {
      "Type": "Pass",
      "Comment": "Chaos experiment completed successfully - system is resilient",
      "Parameters": {
        "status": "SUCCESS",
        "message": "Chaos experiment completed successfully. System demonstrated resilience.",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "experimentStartTime.$": "$.experimentMetadata.experimentStartTime",
        "experimentEndTime.$": "$$.State.EnteredTime",
        "targetInstance": {
          "instanceId.$": "$.selectedTarget.instanceId",
          "availabilityZone.$": "$.selectedTarget.availabilityZone"
        },
        "healthChecks": {
          "preExperiment": {
            "status.$": "$.preExperimentHealth.healthStatus",
            "summary.$": "$.preExperimentHealth.summary"
          },
          "postExperiment": {
            "status.$": "$.postExperimentHealth.healthStatus",
            "summary.$": "$.postExperimentHealth.summary"
          }
        },
        "conclusion": "System successfully withstood infrastructure failure and auto-recovered"
      },
      "ResultPath": "$.result",
      "Next": "LogSuccessMetrics"
    },

    "LogSuccessMetrics": {
      "Type": "Pass",
      "Comment": "Log success metrics for CloudWatch",
      "End": true
    },

    "SystemDidNotRecover": {
      "Type": "Pass",
      "Comment": "System failed to recover within acceptable timeframe",
      "Parameters": {
        "status": "FAILED",
        "reason": "SystemRecoveryFailure",
        "message": "System did not return to healthy state after chaos injection",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "experimentStartTime.$": "$.experimentMetadata.experimentStartTime",
        "experimentEndTime.$": "$$.State.EnteredTime",
        "targetInstance": {
          "instanceId.$": "$.selectedTarget.instanceId",
          "availabilityZone.$": "$.selectedTarget.availabilityZone"
        },
        "healthChecks": {
          "preExperiment": {
            "status.$": "$.preExperimentHealth.healthStatus",
            "summary.$": "$.preExperimentHealth.summary"
          },
          "postExperiment": {
            "status.$": "$.postExperimentHealth.healthStatus",
            "summary.$": "$.postExperimentHealth.summary"
          }
        },
        "recommendation": "Review Auto Scaling configuration and instance health checks"
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "ExperimentAbortedUnhealthy": {
      "Type": "Pass",
      "Comment": "Experiment aborted - system was not healthy before starting",
      "Parameters": {
        "status": "ABORTED",
        "reason": "PreExperimentUnhealthy",
        "message": "Chaos experiment aborted. System was not healthy before injection.",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "preExperimentHealth": {
          "status.$": "$.preExperimentHealth.healthStatus",
          "summary.$": "$.preExperimentHealth.summary"
        },
        "recommendation": "Investigate and resolve existing health issues before running chaos experiments"
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "ExperimentFailedPreCheck": {
      "Type": "Pass",
      "Comment": "Experiment failed during pre-experiment health check",
      "Parameters": {
        "status": "FAILED",
        "reason": "PreCheckError",
        "message": "Failed to execute pre-experiment health check",
        "error.$": "$.error",
        "experimentId.$": "$.experimentMetadata.experimentId"
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "ExperimentFailedTargetSelection": {
      "Type": "Pass",
      "Comment": "Experiment failed during target instance selection",
      "Parameters": {
        "status": "FAILED",
        "reason": "TargetSelectionError",
        "message": "Failed to select target instance from Auto Scaling Group",
        "error.$": "$.error",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "preExperimentHealth": {
          "status.$": "$.preExperimentHealth.healthStatus",
          "summary.$": "$.preExperimentHealth.summary"
        }
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "ExperimentFailedInjection": {
      "Type": "Pass",
      "Comment": "Experiment failed during chaos injection",
      "Parameters": {
        "status": "FAILED",
        "reason": "InjectionError",
        "message": "Failed to inject failure (terminate instance)",
        "error.$": "$.error",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "targetInstance": {
          "instanceId.$": "$.selectedTarget.instanceId",
          "availabilityZone.$": "$.selectedTarget.availabilityZone"
        }
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "ExperimentFailedPostCheck": {
      "Type": "Pass",
      "Comment": "Experiment failed during post-experiment health check",
      "Parameters": {
        "status": "FAILED",
        "reason": "PostCheckError",
        "message": "Failed to execute post-experiment health check",
        "error.$": "$.error",
        "experimentId.$": "$.experimentMetadata.experimentId",
        "targetInstance": {
          "instanceId.$": "$.selectedTarget.instanceId",
          "availabilityZone.$": "$.selectedTarget.availabilityZone"
        },
        "failureInjection": {
          "action.$": "$.failureInjection.action",
          "message.$": "$.failureInjection.message"
        }
      },
      "ResultPath": "$.result",
      "Next": "LogFailureMetrics"
    },

    "LogFailureMetrics": {
      "Type": "Pass",
      "Comment": "Log failure metrics for CloudWatch",
      "End": true
    }
  }
}
